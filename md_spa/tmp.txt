diff --git a/md_spa/viscosity.py b/md_spa/viscosity.py
index a37069c..edb6b47 100644
--- a/md_spa/viscosity.py
+++ b/md_spa/viscosity.py
@@ -548,7 +548,7 @@ def keypoints2csv(filename, fileout="viscosity.csv", mode="a", delimiter=",", ti
     else:
         fm.write_csv(fileout, output, mode=mode)
 
-def shear_modulus2csv(filename, fileout="shear_modulus.csv", mode="a", delimiter=",", title=None, additional_entries=None, additional_header=None, fit_kwargs={}, file_header_kwargs={}):
+def shear_modulus2csv(filename, fileout="shear_modulus.csv", mode="a", delimiter=",", title=None, additional_entries=None, additional_header=None, fit_exp_kwargs={}, fit_stretched_exp_kwargs={}, fit_two_exp_kwargs={}, fit_limits=(None,None), show_plot=False, save_plot=False, plot_name="shear_modulus.png", verbose=False,):
     """
     Given the path to a csv file containing viscosity coefficient vs. time data, extract key values and save them to a .csv file. The file of cumulative_integral data should have a first column with distance values, followed by columns with radial distribution values. These data sets will be distinguished in the resulting csv file with the column headers
 
@@ -568,10 +568,24 @@ def shear_modulus2csv(filename, fileout="shear_modulus.csv", mode="a", delimiter
         This iterable structure can contain additional information about this data to be added to the beginning of the row
     additional_header : list, Optional, default=None
         If the csv file does not exist, these values will be added to the beginning of the header row. This list must be equal to the `additional_entries` list.
-    fit_kwargs : dict, Optional, default={}
-        Keywords for ``find_green_kubo_viscosity`` or ``find_einstein_viscosity`` functions depending on ``method``
-    file_header_kwargs : dict, Optional, default={}
-        Keywords for ``md_spa_utils.os_manipulation.file_header`` function    
+    fit_exp_kwargs : dict, Optional, default={}
+        Keywords for ``cfit.exponential_decay``
+    fit_stretched_exp_kwargs : dict, Optional, default={}
+        Keywords for ``cfit.stretched_exponential_decay``
+    fit_two_exp_kwargs : dict, Optional, default={}
+        Keywords for ``cfit.two_exponential_decays``
+    fit_limits : tuple, Optional, default=(None,None)
+        Choose the time values to frame the area from which to estimate the viscosity so that, ``fit_limits[0] < time < fit_limits[1]``.
+    show_plot : bool, Optional, default=False
+        choose to show a plot of the fit
+    save_plot : bool, Optional, default=False
+        choose to save a plot of the fit
+    title : str, Optional, default=None
+        The title used in the Gshear plot, note that this str is also added as a prefix to the ``plot_name``.
+    plot_name : str, Optional, default="shear_modulus.png"
+        If ``save_plot==True`` the Gshear will be saved with the viscosity value marked in blue, The ``title`` is added as a prefix to this str
+    verbose : bool, Optional, default=False
+        Will print intermediate values or not
 
     Returns
     -------
@@ -605,115 +619,104 @@ def shear_modulus2csv(filename, fileout="shear_modulus.csv", mode="a", delimiter
             flag_add_header = True
 
     data = np.transpose(np.genfromtxt(filename, delimiter=delimiter))
-    tmp_kwargs = copy.deepcopy(fit_kwargs)
+    tmp_kwargs = copy.deepcopy(fit_exp_kwargs)
     if "title" not in tmp_kwargs and title != None:
         tmp_kwargs["title"] = title
-
-    parameters, stnderror = fit_shear_modulus(data[0], data[1], data[2], **tmp_kwargs)
-    tmp_list = [val for pair in zip(parameters, stnderror) for val in pair]
-    output = [list(additional_entries)+[title]+list(tmp_list)]
-    file_headers = ["Group", "G_inf", "G_inf StD", "tau", "tau SE"]
-
-    if not os.path.isfile(fileout) or mode=="w":
-        if flag_add_header:
-            file_headers = list(additional_header) + file_headers
-        fm.write_csv(fileout, output, mode=mode, header=file_headers)
-    else:
-        fm.write_csv(fileout, output, mode=mode)
-
-def fit_shear_modulus(time, Gshear, Gshear_error, fit_limits=(None,None), show_plot=False, title=None, save_plot=False, plot_name="shear_modulus.png", verbose=False, fit_kwargs={}):
-    """
-    Fit an exponential decay to the time dependent shear modulus
-
-    Parameters
-    ----------
-    time : numpy.ndarray
-        Array of time values corresponding to pressure tensor data
-    Gshear : numpy.ndarray
-        Time dependent shear modulus at each time frame
-    Gshear_error : numpy.ndarray
-        Variation in shear modulus for each time frame. The inverse of these values are used to weight the fitting process.
-    fit_limits : tuple, Optional, default=(None,None)
-        Choose the time values to frame the area from which to estimate the viscosity so that, ``fit_limits[0] < time < fit_limits[1]``.
-    show_plot : bool, Optional, default=False
-        choose to show a plot of the fit
-    save_plot : bool, Optional, default=False
-        choose to save a plot of the fit
-    title : str, Optional, default=None
-        The title used in the Gshear plot, note that this str is also added as a prefix to the ``plot_name``.
-    plot_name : str, Optional, default="shear_modulus.png"
-        If ``save_plot==True`` the Gshear will be saved with the viscosity value marked in blue, The ``title`` is added as a prefix to this str
-    verbose : bool, Optional, default=False
-        Will print intermediate values or not
-    fit_kwargs : dict, Optional, default={}
-        Keyword arguements for exponential functions in :func:`custom_fit.exponential_decay`
-
-    Returns
-    -------
-    parameters : numpy.ndarray
-        Parameters from :func:`custom_fit.exponential_decay` fit, G_inf and tau_Maxwell
-    uncertainties : numpy.ndarray
-        Standard error for parameters from ``lmfit``
-
-    """
-
-    if not dm.isiterable(time):
-        raise ValueError("Given distances, time, should be iterable")
-    else:
-        time = np.array(time)
-    if not dm.isiterable(Gshear):
-        raise ValueError("Given Gshear, should be iterable")
-    else:
-        Gshear = np.array(Gshear)
-
-    if len(fit_limits) != 2:
-        raise ValueError("`fit_limits` should be of length 2.")
+    tmp2_kwargs = copy.deepcopy(fit_stretched_exp_kwargs)
+    if "title" not in tmp_kwargs and title != None:
+        tmp2_kwargs["title"] = title
 
     if fit_limits[1] != None:
         try:
-            Gshear = Gshear[time < fit_limits[1]]
-            Gshear_error = np.array(Gshear_error)[time < fit_limits[1]]
-            time = time[fit_limits[1] > time]
+            data = data[:, data[0] < fit_limits[1]]
         except:
             pass
     if fit_limits[0] != None:
         try:
-            Gshear = Gshear[fit_limits[0] < time]
-            Gshear_error = np.array(Gshear_error)[fit_limits[0] < time]
-            time = time[fit_limits[0] < time]
+            data = data[:, data[0] > fit_limits[0]]
         except:
             pass
 
-    Gshear0 = Gshear[0] if not np.isnan(Gshear[0]) else Gshear[1]
+    Gshear0 = data[1,0] if not np.isnan(data[1,0]) else data[1,1]
     if np.isnan(Gshear0):
         raise ValueError("Why are your first two values NaN???")
 
-    tmp_kwargs = copy.deepcopy(fit_kwargs)
+    tmp_kwargs = copy.deepcopy(fit_exp_kwargs)
+    tmp2_kwargs = copy.deepcopy(fit_stretched_exp_kwargs)
+    tmp3_kwargs = copy.deepcopy(fit_two_exp_kwargs)
     if "weighting" not in tmp_kwargs:
-        tmp_kwargs["weighting"] = np.array([1/x if x > np.finfo(float).eps else 1/np.finfo(float).eps for x in Gshear_error/Gshear0])
+        tmp_kwargs["weighting"] = np.array([1/x if x > np.finfo(float).eps else 1/np.finfo(float).eps for x in data[2]/Gshear0])
+        tmp2_kwargs["weighting"] = np.array([1/x if x > np.finfo(float).eps else 1/np.finfo(float).eps for x in data[2]/Gshear0])
+        tmp3_kwargs["weighting"] = np.array([1/x if x > np.finfo(float).eps else 1/np.finfo(float).eps for x in data[2]/Gshear0])
 
     if "verbose" not in tmp_kwargs:
         tmp_kwargs["verbose"] = verbose
+        tmp2_kwargs["verbose"] = verbose
+        tmp3_kwargs["verbose"] = verbose
 
-    parameters, uncertainties = cfit.exponential_decay(time, Gshear/Gshear0, **tmp_kwargs)
+    # Maxwell Relaxation Exp Decay
+    parameters, uncertainties = cfit.exponential_decay(data[0], data[1]/Gshear0, **tmp_kwargs)
     parameters[0] *= Gshear0
     uncertainties[0] *= Gshear0
+    tmp_list = [val for pair in zip(parameters, uncertainties) for val in pair]
+    # Stretched Exp Decay
+    parameters2, uncertainties2 = cfit.stretched_exponential_decay(data[0], data[1]/Gshear0, **tmp2_kwargs)
+    tmp_list += [Gshear0, None] + [val for pair in zip(parameters2, uncertainties2) for val in pair]
+    # Integral of Eq 10 in DOI: 10.33011/livecoms.1.1.6324
+    if "kwargs_parameters" not in tmp3_kwargs:
+        tmp3_kwargs["kwargs_parameters"] = {}
+    tmp3_kwargs["kwargs_parameters"].update({"t1": {"value": parameters[1], "vary": False}, "a1": {"vary": False}})
+    tmp_output2a, _ = cfit.two_exponential_decays(data[0], data[1]/Gshear0, **tmp3_kwargs)
+    tmp3_kwargs["kwargs_parameters"].update({
+        "t1": {"value": tmp_output2a[1], "vary": True}, 
+        "a1": {"value": tmp_output2a[0], "vary": True},
+        "t2": {"value": tmp_output2a[3], "vary": True}, 
+    })
+    parameters3, uncertainties3 = cfit.two_exponential_decays(data[0], data[1]/Gshear0, **tmp3_kwargs)
+    tmp_list += [Gshear0, None] + [val for pair in zip(np.delete(parameters3, 2), np.delete(uncertainties3, 2)) for val in pair]
+    output = [list(additional_entries)+[title]+list(tmp_list)]
+    file_headers = ["Group", "exp G_inf", "exp G_inf StD", "exp tau", "exp tau SE", "str exp G_inf", "str exp G_inf StD", "str exp tau", "str exp tau SE", "str beta tau", "str exp beta SE", "exp G_inf", "exp G_inf StD", "2exp a1", "2exp a1 SE", "2exp tau1", "2exp tau1 SE", "2exp tau2", "2exp tau2 SE",]
 
+    if not os.path.isfile(fileout) or mode=="w":
+        if flag_add_header:
+            file_headers = list(additional_header) + file_headers
+        fm.write_csv(fileout, output, mode=mode, header=file_headers)
+    else:
+        fm.write_csv(fileout, output, mode=mode)
+
+    print(data[0][:2], data[1][:2], data[1][:2]/Gshear0)
     if save_plot or show_plot:
-        plt.fill_between(time, Gshear-Gshear_error, Gshear+Gshear_error, edgecolor=None, alpha=0.15, facecolor="black")
-        plt.plot(
-            time, 
-            cfit._res_exponential_decay({"a1": parameters[0], "t1": parameters[1]}, time, np.zeros(len(time))),
-            "r--", label="Fit", linewidth=0.5
-        )
-        plt.plot(time,Gshear,"k",label="Data", linewidth=0.5)
-        plt.legend(loc="upper right")
-        plt.xlabel("time")
-        plt.ylabel("$G$")
-        plt.ylim((0,np.max(Gshear+Gshear_error)))
-        plt.xlim((0, 4*parameters[1]))
+        fig, axs = plt.subplots(1,2, figsize=(6,4))
+        for i in range(2):
+            axs[i].fill_between(data[0], data[1]-data[2], data[1]+data[2], edgecolor=None, alpha=0.15, facecolor="black")
+            tmp = cfit._res_exponential_decay({"a1": parameters[0], "t1": parameters[1]}, data[0], np.zeros(len(data[0])))
+            axs[i].plot(
+                data[0], tmp,
+                "r--", label="Exp Fit", linewidth=1
+            )
+            axs[i].plot(
+                data[0],
+                Gshear0*cfit._res_stretched_exponential_decay({"tau": parameters2[0], "beta": parameters2[1]}, data[0], np.zeros(len(data[0]))),
+                "g-.", label="Stretched Exp Fit", linewidth=1
+            )
+            axs[i].plot(
+                data[0],
+                Gshear0*cfit._res_two_exponential_decays({"a1": parameters3[0], "t1": parameters3[1], "a2": parameters3[2], "t2": parameters3[3]}, data[0], np.zeros(len(data[0]))),
+                color="b", linestyle=":", label="Two Exp Fit", linewidth=1
+            )
+            axs[i].plot( data[0], data[1], "k", label="Data", linewidth=1)
+            if i == 0:
+                axs[i].legend(loc="upper right")
+                axs[i].set_ylim((0, np.max(data[1]+data[2])))
+            else:
+                axs[i].set_yscale('log')
+                axs[i].set_xscale('log')
+                axs[i].set_ylim((tmp[np.where(data[0]<4*parameters[1])[0][-1]], np.max(data[1]+data[2])))
+            axs[i].set_xlabel("time")
+            axs[i].set_ylabel("$G$")
+            axs[i].set_xlim((0, 6*parameters[1]))
         if title != None:
-            plt.title(title)
+            axs[i].set_title(title)
         plt.tight_layout()
         if save_plot:
             if title != None:
@@ -724,8 +727,6 @@ def fit_shear_modulus(time, Gshear, Gshear_error, fit_limits=(None,None), show_p
             plt.show()
         plt.close("all")
 
-    return parameters, uncertainties
-
 
 def find_green_kubo_viscosity(time, cumulative_integral, integral_error, fit_limits=(None,None), weighting_method="b-exponent", b_exponent=None, tcut_fraction=0.4, show_plot=False, title=None, save_plot=False, plot_name="green-kubo_viscosity.png", verbose=False, fit_kwargs={}):
     """
